\chapter{Обобщенная информационная модель}
В данном разделе вводится описание конфигурации множества контролируемых параметров,
представленное с помощью конфигурационного файла и использованием расширяемого языка разметки XML, правил его оформления XSD.
Также приводится описание необходимых сущностей для представления
на программном уровне объектов предметной области.


\section{\todo{Онтология \ldots}}\label{sec:ontology}
Следуя положениям, изложенным в работах \cite{journal:vestnic_novosib:palchunov, journal:naukovedenie:serdukov},
введем следующие понятия.

\textbf{Сигнатура предметной области.}
В данной работе рассматривается предметная область, содержащая обмен данными по промышленной сети Modbus,
и выполнение неких действий при достижении условий -- в формализации предметной области используются только понятия-свойства,
описывающие конкретные данные, передаваемые по сети. Все понятия делятся на три класса:

\todo{\textit{Если ничем не ограничено именование PQD, то я предпочел бы TCA - tag,condition,action}}

\begin{itemize}
    \item $\mathbb{T}$ --- класс первичных данных, передаваемых по сети (теги из листинга \ref{lst:modbus_tags_example} приложения \ref{app:sec:modbus_tag}).
        Понятия этого класса используются для построения множества допустимых элементов \todo{сценария работы симулятора};
    % 
    \item $\mathbb{C}$ --- класс отношений данных (используется при принятии решений об изменении состояния отслеживаемого параметра).
        Понятия этого класса используются, например, в листинге \ref{lst:comparator:compare}.
    %
    \item $\mathbb{A}$ --- класс всех возможных изменений отслеживаемого параметра (в сценарии перехода один и тот же параметр может фигурировать в разных ролях).
        Понятия этого класса используются в построении сценариев, как показано в листинге \ref{lst:modbus_scenario_example_diagram} приложения \ref{app:sec:modbus_scenario_example_diagram}.
\end{itemize}

Таким образом рассматривается сигнатура, состоящая из конечного числа одноместных предикатных символов \cite[стр. 17]{book:math_logic:guz}.
Далее сигнатуру предметной области $\Delta$ будем обозначать через $\sigma_\Delta$.
Как указано выше, $\sigma_\Delta = \mathbb{T} \cup \mathbb{C} \cup \mathbb{A}$.
Предикаты $P(x) \in \sigma_\Delta$ будем называть \textit{сигнатурными предикатами}.
Через $S(\sigma_\Delta)$ будем обозначать множество всех одноместных бескванторных формул сигнатуры $\sigma_\Delta$.
Заметим, что каждая формула $\varphi(x) \in S(\sigma_\Delta)$ является булевой комбинацией сигнатурных предикатов.


\textbf{Онтология предметной области.}
Для успешного построения образа имитационной модели необходима онтология $S$ предметной области
диспетчерской деятельности $T$ \cite{journal:vestnik_spbgu:ivakin, journal:vestnik_vgtu:shapkin},
в наиболее общем ее понимании, есть совокупность основных понятий этой деятельности $H$ и связей между ними $\Theta$:
$S=\langle H, \Theta\rangle$. 

Для описания онтологии предметной области задается конечное множество аксиом $\mathcal{A}x(\Delta) \subseteq S(\sigma_\Delta)$.
  
\textit{Аксиома общего-частного.}
Иерархическая упорядоченность некоторых понятий должна быть отображена аксиоматически (например, последовательность тегов Modbus, приведенная в листинге \ref{lst:modbus_tags_example}).
Схема таких аксиом следующая: $\left(P_1(x) \to P_2(x) \right)$.
Например: "Если тег \texttt{C1} \textit{Внешнее питание}, то запись 1 бита со значением \texttt{true} по указанному адресу приведет к включению внешнего питания".

\textit{Аксиомы исключения.}
Некоторые понятия являются взаимоисключающими. Схема таких аксиом следующая:
$\left(P_1(x) \to \lnot P_2(x) \right)$.
Например: «Если установлен \textit{режим работы} \texttt{Regime} = 1, то не верно, что \textit{режим работы} \texttt{Regime} равен 2»
или
"Если \textit{внешнее питание} \texttt{C1} не включено, то \textit{напряжение} и \textit{ток} двигателя \texttt{A1} и \texttt{A2} равны нулю, соответственно".

\textit{Аксиома полноты.}
Для описания предметной области рассматривается совокупность допустимых изменений отслеживаемых параметров,
указанных в конфигурационном файле сценария. При этом считается, что в каждом рассматриваемом эпизоде сценария
отражено хотя бы по одному признаку из каждого из трех рассматриваемых классов.
Таким образом, имеется следующая аксиома полноты:
$\left( \left(\bigvee_{P\in\mathbb{T}}P(x)\right) \& \left(\bigvee_{P\in\mathbb{C}}P(x)\right) \& \left(\bigvee_{P\in\mathbb{A}}P(x)\right) \right)$.

Упорядоченная пара $\langle\sigma_\Delta, \mathcal{A}x(\Delta)\rangle$ образует \textit{онтологию} предметной области $\Delta$.
Эта онтология является подмножеством \textit{аналитической теории} предметной области $\Delta$.


\textit{Онтологическая модель предметной области.}
Далее рассмотрим конечное множество $\left\{ s_1, \ldots, s_n \right\}$ правил перехода (подсценариев) в сценарии.
Правило перехода $s_i$ --- это структурированное описание (см. листинг \ref{lst:modbus_scenario_example_diagram} приложения \ref{app:sec:modbus_scenario_example_diagram}).
Заметим, что в правиле перехода однозначно указаны все необходимые условия для выполнения действия,
указан ресурс который должен быть изменен и значение, которое должно быть присвоено этому ресурсу.
Таким образом для $\forall s_i$ возможно описать множество признаков (сигнатурных предикатов), истинных на $s_i$.
Таким образом, для каждого правила перехода строится одноэлементная модель $s_i = \langle \{s_i\}, \sigma_\Delta \rangle$,
которая называется \textit{прецедентом} предметной области $\Delta$.

Для построения онтологической модели необходимо рассмотреть конечное множество 
$\mathbb{S}=\left\{ s_1, \ldots, s_m \right\}$ прецедентов предметной области.
Заметим, что возможны случаи, когда для некоторых $i,j \in \left\{1,\ldots,m\right\} (i\ne j)$
модели $s_i$, $s_j$ будут изоморфны (напряжение и ток двигателя появляется только при выполнении условия $R1 = \mbox{true}$).
Тем не менее эти модели учитываются как формализации различных прецедентов.
Необходимым условием, накладываемым на прецеденты, является истинность на них аналитической теории предметной области.
С теоретико-модельной точки зрения это, в частности, означает, что на каждой модели $s_i$ должно быть истинным множество аксиом
$\mathcal{A}x(\Delta)$, то есть $s_i \vDash \mathcal{A}x(\Delta)$.

Однако, не каждая одноэлементная модель аналитической теории, является прецедентом предметной
области (нельзя обуславливать срабатывание узлов PP\_1 и PP\_2 наличием напряжения на двигателе).
Выбор тех или иных моделей в качестве прецедентов и задает структуру онтологической модели
$\mathfrak{U}_\Delta =\langle \mathbb{S}, \sigma_\Delta \rangle$.
В онтологической модели $\mathfrak{U}_\Delta$ для каждого сигнатурного предиката $P(x) \in \sigma_\Delta$
и для каждого прецедента $s_i \in \mathbb{S}$ имеем $\mathfrak{U}_\Delta \vDash P(s_i)$
тогда и только тогда, когда $s_i \vDash P(s_i)$.
Заметим, что если формула $\varphi(x) \in S(\sigma_\Delta)$ принадлежит множеству аксиом предметной
области $\Delta$, то для $\forall s_i \in \mathbb{S}$  имеет место $\mathfrak{U}_\Delta \vDash\varphi(s_i)$.
Таким образом, на онтологической модели является истинной онтология данной предметной области,
более того, онтологическая модель принадлежит классу моделей аналитической теории предметной области.

Очевидно что одной из особенностей имитационной модели является отсутствие четких границ области применения.
Это означает, что в прогнозируемый период жизненного цикла системы круг решаемых ею задач будет изменяться и расширяться,
что не позволяет четко описать требования к системе, перечислить всю совокупность классов предметной области и
написать программу их реализации.

Устранение этих недостатков возможно при использовании концепции четырехуровневой модели метаданных, приведенной
в таблице \ref{tbl:meta_data_levels} \cite{journal:vestnik_spbgu:ivakin,book:gost:56272,w3c:rdf:lassila}.
\begin{table}[ht!]
    \begin{center}
    \caption{Четырехуровневая модель метаданных}\label{tbl:meta_data_levels}
    \begin{tabular}{|c|c|p{.6\textwidth}|}
    \hline
    \textbf{Уровень} & \textbf{Название} & \textbf{Пример} \\\hline
    %
    3 & Мета-метакласс & RDF \\\hline
    %
    2 & Метакласс & Метакласс (Класс~метаатрибут (имя-строка)...) \\\hline
    %
    1 & Класс & Класс (``Стимул``, [\\
                &&\hspace{5mm}поле (``обозначение``, строка), \\
                &&\hspace{5mm}поле (``назначение``, строка), \\
                &&\hspace{5mm}поле (``значение``, число),\\
                &&\hspace{5mm}поле (``адрес``, число),\\
                &&\hspace{5mm}поле (``тип данных``, число)\\
            &&]);\\
            %
            &&Класс (``Запись при условии'', [\\
                &&\hspace{5mm}поле (``обозначение'', строка),\\
                &&\hspace{5mm}поле (``значение'', число),\\
                &&\hspace{5mm}поле (``условия'', логическое выражение)\\
            &&])\\\hline
    %
    0 & Объект & 
        \texttt{C1} (Внешнее питание, \texttt{true}, 8001); \\
        %
        &&\texttt{W} (Имитация напряжения двигателя, 130~В, $C1 \equiv \mbox{true} \wedge \tau|_{C1\equiv\mbox{true}} \ge 500\mbox{ms}$).
        \\\hline
\end{tabular}
\end{center}
\end{table}
Метаданные --- это данные, описывающие организацию других данных.

В заключении отметим, что необходимость разработки онтологии связана с:
\begin{enumerate}
    \item совместным использованием данных людьми или программными компонентами;
    \item общего понимания структуры информации;
    \item возможности повторного использования знаний в предметной области;
    \item чтобы сделать допущения в предметной области явными;
    \item отделение знаний предметной области от оперативных;
    \item анализ знаний предметной области.
\end{enumerate}
Проиллюстрируем это утверждение при определении типов \texttt{ModbusElement} и правил преобразования
значений Modbus в разделах \ref{sec:modbus_tag} и \ref{sec:writers_def} соответственно.
% Далее рассмотрим положения, изложенные в таблице \ref{tbl:meta_data_levels}, более детально применительно к переменным протокола Modbus.


\section{Определение Modbus тегов} \label{sec:modbus_tag}
Пример конфигурационного файла (\textit{мета-матакласс}) приведен в листинге \ref{lst:modbus_tags_example_configs} в приложении \ref{app:sec:xsd}.
Не смотря на то что в самом протоколе Modbus передаются только целые числа, некоторые производители Modbus-устройств,
в том числе производители средств разработки для программируемых логических контроллеров, расширяют возможности протокола
для передачи вещественных чисел одинарной и двойной точности, так и целочисленных значений размером до восьми байт \cite{book:gost:modbus_program_language}.

Каждый тег описывается тремя обязательными и двумя необязательными атрибутами.
К обязательным относятся:
\begin{itemize}
    \item[\texttt{title}] заголовок тега, относящийся к предметной области;
    \item[\texttt{address}] адрес тега, согласованный с адресным пространством контроллера;
    \item[\texttt{type}] тип передаваемого значения, который может принимать следующие значения, в зависимости от группы:
    %
    \begin{itemize}
        \item[BOOL] 1 бит;
        \item[WORD] 16 бит;
        \item[DOUBLEWORD] 32 бита;
        \item[REAL] 32 бита;
        \item[LONGREAL] 64 бита.
    \end{itemize}
\end{itemize}
Необязательные атрибуты служат для вспомогательной цели:
\begin{itemize}
    \item[\texttt{position}] первично -- определяет положение сигнального проводника на модуле в сборке контроллера;
    вторично -- обозначает, что это результат промежуточных вычислений контроллера;
    \item[\texttt{description}] описание передаваемого параметра.
\end{itemize}

Теги объединены в конфигурационный файл (\textit{метакласс}), пример которого показан 
в листинге \ref{lst:modbus_tags_example} в приложения \ref{app:sec:modbus_tag}.
В файле содержится совокупность тегов (\textit{классов}),
каждый из которых представляет \textit{объект} --- экземпляр класса \texttt{ModbusElement},
с набором необходимых атрибутов: обозначение, назначение, положение, адрес, тип данных, значение.


\section{Про компоненты, отвечающие за изменение состояние значения \texttt{ModbusElement} в имитаторе АНПА}\label{sec:writers_def}

Наравне с описанием переменных сети Modbus в таблице \ref{tbl:meta_data_levels},
проводится ранжирование параметров, описанных в разделе \ref{sec:model_anpa_params}.
Совокупность свойств описана на уровне \textit{мета-метакласса} (см. листинг \ref{lst:modbus_tags_scenario_configs} приложение \ref{app:sec:xsd}).
Каждый, так называемый, ``захваченный'' параметр описывается на уровне \textit{метакласса},
как показано в листинге \ref{lst:modbus_scenario_example_diagram} приложения \ref{app:sec:modbus_scenario_example_diagram}.
%
Эта конфигурация описывает взаимосвязь \textit{классов}, в смысле, взаимодействия предикатов, построенных на базе 
Modbus переменных, определенных в разделе \ref{sec:modbus_tag}.
Каждое правило изменения представляет собой \textit{объект} в четырехуровневой модели метаданных.
Характеристики \textit{метаклассов} приведены в таблице \ref{tbl:ModbusElementWriterImpl}.

О правилах построения и разнообразии \textit{классов} изложено в следующем разделе \ref{sec:writers_relationship}.


\subsection{Не нормализованная таксономия классов}
    \label{sec:writers_relationship}

На основе анализа предметной области строится не нормализованная\footnote{любой класс может иметь два и более не пересекающихся надкласса}
иерархия классов для управления информационной моделью,
диаграмма взаимосвязи классов представлена на рисунке \ref{fig:modbus_class_uml} \cite[стр. 223]{book:oop:oop_analize}.
\begin{landscape}
    \begin{center}
        \begin{figure}[ht!]
            \includegraphics[height=.88\textheight,keepaspectratio]{modbus_class_relationship.png}
            \caption{UML диаграмма классов имитатора модели АНПА при передачи по шине данных типа Modbus}\label{fig:modbus_class_uml}
        \end{figure}
    \end{center}
\end{landscape}
Базовый класс \texttt{ModbusElement} инкапсулирует в себе представление тега из раздела \ref{sec:modbus_tag}.
Для передачи данных между компонентами системы используется класс \texttt{ModbusData}, производный от \texttt{ModbusElement},
в котором появляется дополнительный член класса \texttt{value} для хранения значения.
Для реализации поведения используется полиморфизм, так как классы имеют один и тот же протокол \cite[стр. 133]{book:oop:oop_analize}.



Интерфейс \texttt{IModbusElementReader} введен для общности,
но в данной работе представляет мало интереса.


\subsection{Жизненный цикл компонента \texttt{IModbusElementWriter}}
Отметим, что этот компонент создается с использованием множественного наследования:
первый супер класс это \texttt{ModbusData}, инкапсулирующий передаваемые данные,
а второй --- \texttt{QObject}, так как необходимо получить "ортогональные свойства"
(механизм сигналов-слотов и обработка сообщений) \cite[стр. 134]{book:oop:oop_analize}.

Каждый экземпляр класса, реализующего интерфейс \texttt{IModbusElementWri\-ter},
функционирует следующим образом, как показано на рисунке \ref{fig:imodbuselementwriter_activity} \cite[стр. 217]{book:oop:oop_analize}.
После создания, компонент находится в пассивном режиме ожидания, до тех пор пока не будет вызван
метод \texttt{IModbusElementWriter::start()}, после чего компонент подписывается на события шины данных по протоколу Modbus
и слушает сообщения об изменениях значений через слот \texttt{IModbusElementWriter::newModbusData()}.
При поступлении данных, удовлетворяющих условиям функции \texttt{IModbusElementWriter::conditionsMet()},
происходит запись значения через интерфейс \texttt{IDeviceWriter} (рисунок \ref{fig:modbus_device_imp}),
испускается сигнал \texttt{IModbusElementWriter::writed()},
флаг \texttt{running} выставляется в значение \texttt{false},
а компонент отписывается от событий по шине данных.
Компонент может быть повторно подписан на события, через вызов метода \texttt{IModbusElementWriter::start()}.

\begin{center}
    \begin{figure}
        \includegraphics[width=.5\textwidth,keepaspectratio]{imodbuselementwriter_activity}
        \caption{Жизненный цикл компонента (см. также листинг \ref{lst:tmpl_method_writerimpl})}\label{fig:imodbuselementwriter_activity}
    \end{figure}
\end{center}


Класс \texttt{ModbusElementWriterImpl} реализует паттерн "Шаблонный метод" (Template method) \cite[стр. 309]{book:pattern:band_of_4},
определяя метод слота \texttt{IModbusElementWriter::newModbusData()}
и защищенный метод \texttt{IModbusElementWriter::write()} --- инвариантную последовательность операций,
определенную виртуальными методами, которые можно переопределить с помощью наследования \cite[стр. 170]{book:tdd:KentBeck}.

\lstinputlisting[
    language=C++,
    caption=Реализация контракта компонента (см. рисунок \ref{fig:imodbuselementwriter_activity}),
    label=lst:tmpl_method_writerimpl
        ]{Dissertation/listings/cpp/writerimpl_template_method.hpp}


\subsection{\todo{Условия перехода}}
Как видно из рисунка \ref{fig:modbus_class_uml} проверка условий записи описываются с помощью компонента типа
\texttt{ModbusDataRelationed} -- наследника класса \texttt{ModbusData}.
Этот класс содержит в себе \texttt{value} от родительского класса и правило отношения \texttt{Relation}.
При поступлении новых данных по шине Modbus происходит сравнение значений (листинг \ref{lst:comparator:compare}).
\lstinputlisting[
    language=C++,
    caption=Вспомогательный метод для анализа поступающих данных,
    label=lst:comparator:compare
        ]{Dissertation/listings/cpp/comparator.hpp}


Перейдем к более подробному рассмотрению реализаций интерфейса \texttt{IModbusElementWriter}.

\subsubsection{Запись с единичным условием}\label{sec:guard}
Циклограмма функционирования класса \texttt{ModbusGuardedWriter} приведена на рисунке \ref{fig:modbus_guarded_writed}.
Этот класс переопределяет метод родительского класса \texttt{IModbusElementWriter::conditionsMet()}.
\begin{center}
    \begin{figure}[h!]
        \includegraphics[width=.8\textwidth,keepaspectratio]{modbus_guarded_writer.png}
        \caption{Циклограмма записи значения при выполнении условия в момент времени $\tau_1=100$.}\label{fig:modbus_guarded_writed}
    \end{figure}
\end{center}
Как видно из рисунка выполнение условия происходит в момент времени $\tau_1=100$ условных единиц времени,
сразу же по переднему фронту происходит запись нового значения, которое сохраняется даже после окончания
выполнения логического условия \texttt{cond} в $\tau_2=300$.


\subsubsection{Запись со множественными условиями}
Циклограмма функционирования класса \texttt{ModbusMultiguardedWriter} приведена на рисунке \ref{fig:modbus_multiguarded_writed}.
Этот класс переопределяет метод родительского класса \texttt{ModbusElementWriterImpl::newModbusData()},
так как необходимо следить за множеством тегов через этот слот,
заполняется ассоциативный массив (например, \texttt{std::map<std::string, bool>} у которого ключем является
название тега \texttt{modbusio::ModbusElement::title()}, а значением результат \todo{надо посмотреть в коде \ldots})
\begin{center}
    \begin{figure}[h!]
        \includegraphics[width=.8\textwidth,keepaspectratio]{modbus_multiguarded_writer.png}
        \caption{Циклограмма записи значения при выполнении множественных условий.}\label{fig:modbus_multiguarded_writed}
    \end{figure}
\end{center}
Как видно из этого рисунка, значение не будет записано до тех пор, пока не будут
выполнены все условия, даже если после установления одного из условий оно меняется
(как показано для второго условия на 100 единице времени). Аналогично с \texttt{ModbusGuardedWriter}
после того как значение было записано, выполнение условий не контролируется, 
при этом записанное значение сохраняется, но может быть независимо изменено по другим причинам,
так как компонент больше не владеет ресурсом и отписывается от событий.


\subsubsection{Отложенная запись с единичным условием}
Циклограмма функционирования класса \texttt{ModbusDelayedWriter} приведена на рисунке \ref{fig:modbus_delayed_writer}.
Этот класс уточняет метод родительского класса \texttt{ModbusGuardedWriter::conditionsMet()},
при выполнении условия которого запускается таймер на время задержки \texttt{delay},
по окончании которого происходит запись значения.
\begin{center}
    \begin{figure}[h!]
        \includegraphics[width=.8\textwidth,keepaspectratio]{modbus_delayed_writer.png}
        \caption{Циклограмма отложенной записи значения при выполнении единственного условия.}\label{fig:modbus_delayed_writer}
    \end{figure}
\end{center}
Класс позволяет устанавливать значение после выполнения условия и по истечению задержки $\tau$.
По окончании таймера на запись значение выражения \texttt{Condition} не анализируется
и запись происходит в любом случае.


\subsubsection{Отложенная запись со множеством условий}
Циклограмма функционирования класса \texttt{ModbusDelayedMultiguardWriter} приведена на рисунке \ref{fig:modbus_delayed_multiguarded_writer}.
Этот компонент переопределяет метод \texttt{IModbusElementWriter::newModbusData()},
в тоже время запуск таймера осуществляется при достижении истинного значения
функции супер-класса \texttt{ModbusMultiguardedWriter}.
\begin{center}
    \begin{figure}[h!]
        \includegraphics[width=.8\textwidth,keepaspectratio]%
            {modbus_delayed_multiguarded_writer.png}
        \caption{Циклограмма отложенной записи значения при выполнении множественных условий.}\label{fig:modbus_delayed_multiguarded_writer}
    \end{figure}
\end{center}


\subsubsection{Периодическая запись}
Данный компонент предназначен для реализации периодических событий, как показано на диаграмме \ref{fig:modbus_periodic_writer}.
При захвате управления дискретной переменной, ее значение инвертируется каждый период
$f_i(x; \tau) = \lnot f_{i-1}(x; \tau), f(x; \tau) \in \{True, False\}$
(на графике сверху захвачен булевский тег, период равен 25 единиц времени, длительность не ограничена).
При захвате вещественной переменной значение меняется по закону
$f_i(x,\Delta x; \tau) = f_{i-1}(x,\Delta x; \tau) + \Delta x, \Delta x \in \mathcal{R}$
(на графике снизу период равен 50 единиц времени, $\Delta x = 10$ на 200 единиц времени).
\begin{center}
    \begin{figure}[h!]
        \includegraphics[width=.8\textwidth,keepaspectratio]{modbus_periodic_writer.png}
        \caption{Циклограмма периодической записи значения.}\label{fig:modbus_periodic_writer}
    \end{figure}
\end{center}
Этот компонент используется, например, для управления значениями количества оборотов,
количества транзакций и пакетов, переданных от контроллера к программе верхнего уровня,
при захвате вещественных переменной.
Очевидно, что приращение $\Delta x$ может быть как положительным, так и отрицательным.

Если в конфигурации сценария (листинг \ref{lst:modbus_periodic_writer_xml}) имеется атрибут
\texttt{duration}, компонент будет работать от выполнения условий до окончания указанной длительности.
В противном случае обновление значений будет происходить до момента прекращения работы
путем вызова функции \texttt{IModbusElementWriter::reset()}.


\subsection{Реализация интерфейса \texttt{IDeviceWriter}}
При реализации интерфейса \texttt{IDeviceWriter} используется возможность множественного наследование языка программирования \cpp,
одним из родителей является интерфейс \texttt{IDeviceWriter},
а вторым --- класс библиотеки \texttt{Qt}, обеспечивающий реализацию физической передачи информации по протоколу Modbus
\texttt{QModbusTcpServer}, так как обмен происходит по разновидности протокола Modbus TCP/IP.
Упрощенная реализация показана в листинге \ref{lst:imodbus_device_impl}.
\begin{center}
    \begin{figure}
        \includegraphics[width=.9\textwidth,keepaspectratio]{modbus_device_impl.png}
        \caption{Реализация устройства для записи значений по протоколу Modbus}\label{fig:modbus_device_imp}
    \end{figure}
\end{center}
\lstinputlisting[
    language=C++,
    caption=Простейшая реализация \texttt{IDeviceWriter} устройства,
    label=lst:imodbus_device_impl]
        {Dissertation/listings/cpp/dummydeviceimpl.hpp}
Таким образом используется интерфейс вместо конкретной реализации \cite[стр. 47-48]{book:pattern:head_first}


\subsection{Описание конфигурационного файла для компонентов интерфейса \texttt{IModbusElementWriter}}
Каждая группа должна быть помещена в корневой элемент \texttt{Scenario},
как показано в листинге \ref{lst:modbus_scenario_example_diagram} приложения \ref{app:sec:modbus_scenario_example_diagram}.

Каждый компонент помещается внутри тега \texttt{Writer} (представляющий класс всех возможных изменений $\mathbb{A}$),
с обязательным текстовым атрибутом \texttt{tag}, который указывает каким ресурсом владеет данный компонент
и обязательным атрибутом \texttt{value} (см. листинг \ref{lst:modbus_tags_scenario_configs}).
Также есть ряд необязательных атрибутов, о которых будет сказано отдельно. 
Одновременно владеть одним и тем же ресурсом могут несколько компонентов (как будет показано ниже).
Далее следует секция условий --- \texttt{Conditions},
описывающая классы отношений $\mathbb{C}$ (см. раздел \ref{sec:ontology}).
Каждое условие описывается логической операцией отношения \texttt{relation} для смежного параметра,
указанного в обязательном поле \texttt{tag} и связанного с ним значения \texttt{value}.
Элемент \texttt{relation} принимает одно из следующих значений:
\texttt{eq} ($=$),
\texttt{ne} ($\neq$),
\texttt{gt} ($>$),
\texttt{lt} ($<$),
\texttt{ge} ($\geq$),
\texttt{le} ($\leq$), по аналогии с обозначениями в языке Fortran.
Отношение типа \texttt{eq} считается отношением по умолчанию,
все остальные отношения же необходимо указывать явным образом.
Необязательным полем является поле \texttt{Purpose}, в котором размещается информация для
обозначения назначения компонента в сценарии.

\subsubsection{ModbusGuardedWriter}
Рассмотрим более подробно описание компонента для компонента с единичным условием записи,
который размещается в элементе \texttt{Guarded} листинга \ref{lst:modbus_guarded_writer_xml}:
\lstinputlisting[
    language=MyXML,
    caption=Пример конфигурации \texttt{ModbusGuardedWriter},
    label=lst:modbus_guarded_writer_xml]
        {Dissertation/listings/xml/guarded.xml}
Захватывается управление над тегом \texttt{A1}, которой будет присвоено значение 160
при выполнении условия \texttt{R1 = true}.
Иными словами при истинности предиката $P$ будет выполнено действие $Q$:
$P(R1=\mbox{true}) \to Q(A1=160)$.


\subsubsection{ModbusMultiguardedWriter}
Для описания компонента со множественными условиями, используется следующий формат,
который размещается в элементе \texttt{Multiguarded} листинга \ref{lst:modbus_multiguarded_writer_xml}:
\lstinputlisting[
    language=MyXML,
    caption=Пример конфигурации \texttt{ModbusMultiguardedWriter},
    label=lst:modbus_multiguarded_writer_xml]
        {Dissertation/listings/xml/multiguarded.xml}
Переменной \texttt{Regime} будет присвоено значение 1, как только 
одновременно будет выполнено два условия: $Regime = 1: \{A1 \ge 150 \wedge C1 = true\}$.
Таким образом $P(x_1,\ldots,x_n) = P(A1\ge150, C1=\mbox{true}) \to Q(Regime=1)$.

\subsubsection{ModbusDelayedWriter и ModbusDelayedMultiguardWriter}
Компоненты этого типа располагаются в окружении тегов элементов \texttt{Delayed} и \texttt{Multidelayed}, соответственно,
как показано в листинге \ref{lst:modbus_delayed_writer_xml}.
\lstinputlisting[
    language=MyXML,
    caption=Пример конфигурации \texttt{ModbusDelayedWriter} и \texttt{ModbusDelayedMultiguardWriter},
    label=lst:modbus_delayed_writer_xml]
        {Dissertation/listings/xml/delayed.xml}
Захватывается управление переменной \texttt{PP\_1}, которой будет установлено значение \texttt{true}
через 50 единиц времени, как только будут выполнены два условия:
$PP\_1 = \mbox{true}: \{R1 = \mbox{true} \wedge A1 \le 150\}$.
Или используя предикатные обозначения
$P(x_1,\ldots,x_n) = P(A1\le150, R1=\mbox{true}, \tau=50) \to Q(PP\_1=\mbox{true})$.


\subsubsection{ModbusPeriodicWriter}
Данный компонент располагается внутри элемента \texttt{Period} в конфигурационном файле сценария,
согласно листингу \ref{lst:modbus_periodic_writer_xml}.
\lstinputlisting[
    language=MyXML,
    caption=Пример конфигурации \texttt{ModbusPeriodicWriter},
    label=lst:modbus_periodic_writer_xml]
        {Dissertation/listings/xml/periodic.xml}
В данном примере дистанция, ассоциированная с переменной \texttt{Distance}, увеличивается на 100 единиц каждые 1000 единиц времени,
при выполнении ряда условий, а именно: $\{C1 = true \wedge A1 > 100 \wedge A1 \le 150 \}$ или
увеличивается на теже 100 единиц, но с периодом 500 единиц, когда достигаются следующие условия:
$\{C1 = true \wedge A1 > 150\}$
Отметим, что для этого компонента начальное значение устанавливается с помощью атрибута \texttt{value}
при вызове метода \texttt{IModbusElementWriter::start()}.


\subsection{Сводная таблица наследников \texttt{IModbusElementWriter}}
Общая информация о компонентах представлена в таблице \ref{tbl:ModbusElementWriterImpl}.
Из этой таблицы видно, что использование наследования совместно с паттерном "шаблонный метод"
позволяет переопределять поведение компонентов, обеспечивая выполнение контрактов наследниками интерфейса
\cite[стр. 124-125]{book:oop:oop_analize}.

\begin{table}[hb!]
\begin{center}
\caption{Сводная таблица \textit{метаклассов} модели АНПА.}\label{tbl:ModbusElementWriterImpl}
\begin{tabular}{|l|c|c|c|c|c|c||c|c|}
\hline
    \multicolumn{1}{|c|}{\multirow{2}{*}{Наследники}} &
    \multicolumn{6}{c||}{\textbf{атрибуты}} &
    \multicolumn{2}{c|}{\textbf{override}} \\ \cline{2-9} %Переопределенные методы наследника
    \multicolumn{1}{|c|}{}     &
        \rotatebox{90}{tag} & \rotatebox{90}{value}  & \rotatebox{90}{delay}  & \rotatebox{90}{period} &
        \rotatebox{90}{delta} & \rotatebox{90}{duration} &
        \rotatebox{90}{conditionsMet} & \rotatebox{90}{newModbusData} \\ \hline
    \texttt{ModbusGuardedWriter}              & +    & +      & -      & -      & - &-     & + & -  \\ \hline
    \texttt{ModbusMultiguardedWriter}         & +    & +      & -      & -      & - &-     & + & -  \\ \hline
    \texttt{ModbusDelayedWriter}              & +    & +      & +      & -      & - &-     & - & +  \\ \hline
    \texttt{ModbusDelayedMultiguardWriter}    & +    & +      & +      & -      & - &-     & - & +  \\ \hline
    \texttt{ModbusPeriodicWriter}             & +    & +      & -      & +      & + &$\pm$ & + & -  \\ \hline
\end{tabular}
\end{center}
\end{table}


\input{Dissertation/manager.tex}

\section*{Выводы}
Таким образом можно использовать унифицированный способ представления сценария для имитатора \ldots



% \section{Распределение ролей}
% На стороне СК создается экземпляр клиента сети modbus,
% имитатор представляет сервер (см. главу \ref{ch:ch2}).
% \section{Конфигурационный файл}\label{sec:ch2/sec1}
% Общее пространство данных modbus у ПО СК и имитатора \ldots
% \section{Паттерн MVC}
% Поверх множества данных modbus используется паттерн проектирования модель-вид-контроллер \cite{book:pattern:band_of_4}.
% Библиотека Qt позволяет создавать модель данных, наследуя поведение от \lstinline[language=C]!QAbstractTableModel!,
% переобпределяя реализацию методов для чтения-записи данных в модель.
% \subsection{Пояснение в реализации методов}
% \subsection{Преимущества такого подхода}
